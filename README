# mDNS and DNS-SD Implementation Guide
# Table of Contents
1. [Core Concepts](#core-concepts)
2. [Protocol Specifications](#protocol-specifications)
3. [Message Structure](#message-structure)
4. [Record Types](#record-types)
5. [Implementation Steps](#implementation-steps)
6. [Network Configuration](#network-configuration)

# Core Concepts

# DNS (Domain Name System)
- System for converting URLs to IP addresses
- Example: "google.com" → 172.217.23.110

# mDNS (Multicast DNS)
- Enables DNS operations in local networks
- Uses ".local" domain naming convention
- Example: "MyComputer.local"

# DNS-SD (DNS-based Service Discovery)
- Enables device and service discovery within local networks
- Allows automatic service detection and interaction
- Example: Mobile phone discovering and communicating with a network printer

# Protocol Specifications

# Network Configuration
- IPv4 prefix: 169.254/16
- IPv6 prefix: FE80::/10
- Local address resolution:
  - IPv4: 224.0.0.251
  - IPv6: FF02::FB
- UDP port: 5353

# Query Types
1. One-shot queries
2. Continuous/ongoing queries

# Query Rules
- Responses must not contain additional queries
- Random delay between queries:
  - Normal: 20-120ms
  - Truncated sets: 400-500ms

# Packet Limitations
- Header sizes:
  - IPv4: 20 bytes
  - IPv6: 40 bytes 
  - UDP header: 8 bytes
- Maximum packet size:
  - Theoretical limit: 9000 bytes
  - Recommended limit: 1500 bytes

# Message Structure

# Header Fields
| Field | Query Value | Response Value |
|-------|-------------|----------------|
| ID | 0 | Ignored |
| QR | 0 | 1 |
| OPCODE | 0 | >0 ignored |
| AA | 0 | 1 |
| TC | 1 if known response | 0 |
| RD | 0 | Ignored |
| RA | 0 | Ignored |
| RCODE | 0 | !=0 ignored |

# Record Types

# TXT Records
- Format: "key=value"
- Maximum size: 200 bytes per record
- Structure example:
```
| 0x09 | key=value | 0x08 | paper=A4 | 0x07 | passreq |
```
- Rules:
  - Missing key: Record ignored
  - Missing value: Treated as boolean (default: true)
  - Recommended: Include "txtvers=1" or "txtvers=8"

# PTR Records
- Format: `_service._proto.name. ttl PTR type CNAME`
- Example: `_printer._tcp.local. 28800 PTR PrintsAlot._printer._tcp.local.`
- Field sizes:
  - service: ≤255 bytes
  - proto: 2 bytes
  - name: ≤255 bytes
  - ttl: 4 bytes (32 bits)
  - type: 2 bytes (16 bits)
  - CNAME: ≤255 bytes

# SRV Records
- Format: `_service._proto.name. ttl IN SRV priority weight port target`
- Example: `_sip._tcp.example.com. 86400 IN SRV 0 5 5060 sipserver.example.com.`
- Field descriptions:
  - service: Service instance name (≤255 bytes)
  - proto: Transport protocol (2 bytes)
  - name: Domain name (≤255 bytes)
  - ttl: Time-to-live (4 bytes)
  - priority: Host priority (16 bits, lower = higher priority)
  - weight: Selection weight for equal priority (2 bytes)
  - port: Service port (2 bytes)
  - target: Host name (≤255 bytes)

# Implementation Steps

1. Device Discovery
   - Send 3 mDNS queries
   - 250ms delay between queries
   - Identify available devices

2. Resource Announcement
   - Broadcast available resources
   - Send updates when resources change
   - Maintain network consistency

3. Client-Server Implementation
   - Client searches and connects to host server
   - Server maintains unique hostname
   - Client selects services via interface
   - Server logs all activities

# Record Conversion Flow
```
SRV → PTR → A → TXT

1. SRV: Define service and host
2. PTR: Create reverse DNS lookup
3. A: Map hostname to IPv4
4. TXT: Add metadata
```

# În cadrul acestui proiect, trebuie să folosim mDNS (Multicast DNS) și DNS-SD (DNS-based Service Discovery), tehnologii esențiale pentru descoperirea serviciilor într-o rețea locală.

# Tipuri de înregistrări DNS utilizate:
SRV: Descrie serviciul, portul și protocolul asociat.
PTR: Indică serviciile disponibile.
A: Înregistrarea adresei IP pentru o anumită gazdă.
TXT: Înregistrări text ce oferă informații suplimentare despre servicii.

# Mediul de dezvoltare și configurarea socket-urilor:
Pentru a implementa mDNS, va trebui să folosim socket-uri pentru a trimite și primi pachete pe adresele multicast. Aceste socket-uri vor folosi protocolul UDP pentru a trimite cereri DNS și a primi răspunsuri. De asemenea, trebuie ca pachetele trimise să respectă structura specifică a mDNS și DNS-SD.

# Mecanisme de caching
Pentru a optimiza aplicația, vom implementa un mecanism de caching. Acest mecanism va stoca rezultatele DNS descoperite pentru o perioadă determinată, bazându-se pe valoarea TTL (Time To Live) a fiecărui pachet. Acest lucru va reduce numărul de cereri de rețea și va îmbunătăți eficiența generală a aplicației.

Pașii de implementare:
# 1. Structurarea pachetelor DNS (SRV, PTR, A)
Mai întâi, trebuie creată o structură de pachete DNS-SD (SRV, PTR, TXT, A) pe care le voi trimite în rețea.

# 2. Monitorizarea resurselor sistemului
Pentru a monitoriza diverse resurse ale sistemului (precum utilizarea procesorului, memoriei și temperatura), vom utiliza un script care utilizează modulele Python potrivite, cum ar fi psutil. Acesta permite preluarea datele despre resursele sistemului și monitorizarea în timp real.

# 3. Expunerea resurselor ca servicii DNS-SD
Crearea unei interfațe care va permite selectarea resurselor pe care vreau să le monitorizez. Apoi, aceste resurse vor fi expuse în rețea sub forma unor înregistrări DNS-SD (SRV). Înregistrările PTR vor fi configurate pentru a arăta către hostname-urile resurselor monitorizate.

# 4. Descoperirea serviciilor în rețeaua locală
O alta parte va fi responsabila pentru descoperirea serviciilor disponibile în rețea. Acesta va trimite cereri multicast și va afișa adresele IP și valorile resurselor asociate fiecărei intrări descoperite.

# 5. Implementarea caching-ului
Pentru a reduce cererile repetate de rețea, trebuie implementat un mecanism de caching. Acest cache va stoca datele descoperite pe baza valorilor TTL ale înregistrărilor DNS. Astfel, se vor economisi resurse și timp, evitând cereri inutile.

# 6. Controlul valorii TTL
În partea de monitorizare, voi implementa o opțiune prin care să pot modifica valoarea TTL pentru fiecare resursă în parte. Acest control îmi va permite să gestionez cât timp rămân valide resursele în cache și să optimizez traficul de rețea.

# Resurse utile
Pentru a înțelege mai bine cum implementez aceste concepte, mă voi baza pe următoarele documente și resurse:

RFC 6762 pentru detalii tehnice despre Multicast DNS (mDNS)
RFC 6763 pentru informații despre DNS-based Service Discovery (DNS-SD)
Documentația pentru socket programming în Python (sau alte limbaje relevante)
